<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Universe Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Import map for Three.js modules from CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
            "three/addons/renderers/SVGRenderer.js": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/renderers/SVGRenderer.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';

        let scene, camera, renderer, controls;
        const planets = [];

        function init() {
            // 1. Scene (场景)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0, 0, 0);

            // 2. Camera (相机)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 150);

            // 3. Renderer (渲染器) - Using SVGRenderer for maximum compatibility.
            renderer = new SVGRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. Controls (轨道控制器)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 5. Lights (灯光)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // 环境光
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 2.5, 500); // 太阳的点光源
            scene.add(pointLight);

            // --- Create Celestial Bodies (创建天体) ---

            createStarfield();
            createSun();
            createSolarSystem();
            createBlackHole();

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // 创建星空背景
        function createStarfield() {
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // 创建太阳
        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(15, 32, 32);
            // MeshBasicMaterial 不受灯光影响，看起来像自身在发光
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00, map: createSunTexture() });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);
        }
        
        // 创建一个简单的太阳纹理
        function createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0.1, 'rgba(255, 220, 150, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 1)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0.8)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        // 创建太阳系
        function createSolarSystem() {
            // (名字, 颜色, 大小, 轨道半径, 公转速度)
            addPlanet("Mercury", 0x8c8c8c, 2, 30, 0.02);
            addPlanet("Venus", 0xa57c1b, 4, 50, 0.012);
            addPlanet("Earth", 0x0077be, 4.5, 75, 0.01);
            addPlanet("Mars", 0xc1440e, 3.5, 100, 0.008);
            addPlanet("Jupiter", 0xd8ca9d, 8, 140, 0.004);
        }

        function addPlanet(name, color, size, distance, speed) {
            const planetGeometry = new THREE.SphereGeometry(size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ color: color });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            // 为了方便计算轨道，我们使用一个 Object3D 作为公转中心
            const pivot = new THREE.Object3D();
            scene.add(pivot);
            pivot.add(planet);

            planet.position.x = distance;

            // 绘制轨道线
            const orbitGeometry = new THREE.RingGeometry(distance - 0.1, distance + 0.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.2 });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);

            planets.push({ name, pivot, speed });
        }

        // 创建黑洞
        function createBlackHole() {
            const blackHoleGroup = new THREE.Group();

            // 黑洞本体
            const holeGeometry = new THREE.SphereGeometry(10, 32, 32);
            const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const hole = new THREE.Mesh(holeGeometry, holeMaterial);
            blackHoleGroup.add(hole);

            // 吸积盘
            const diskGeometry = new THREE.TorusGeometry(25, 8, 2, 100);
            const diskMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffa500, 
                side: THREE.DoubleSide,
                map: createAccretionDiskTexture()
            });
            const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI / 2 + 0.2; // 倾斜
            blackHoleGroup.add(accretionDisk);
            
            blackHoleGroup.position.set(-250, 20, -150);
            scene.add(blackHoleGroup);
            
            // 让吸积盘动起来
            planets.push({ name: "BlackHoleDisk", pivot: accretionDisk, speed: 0.015 });
        }
        
        function createAccretionDiskTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(128, 128, 50, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 1)');
            gradient.addColorStop(0.8, 'rgba(255, 0, 0, 1)');
            gradient.addColorStop(1, 'rgba(128, 0, 128, 0.5)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 256);
            return new THREE.CanvasTexture(canvas);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 更新行星公转
            planets.forEach(p => {
                if (p.name === "BlackHoleDisk") {
                    p.pivot.rotation.z += p.speed; // 吸积盘自转
                } else {
                    p.pivot.rotation.y += p.speed; // 行星绕太阳公转
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
